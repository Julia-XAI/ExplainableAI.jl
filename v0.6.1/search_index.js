var documenterSearchIndex = {"docs":
[{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"EditURL = \"../../literate/lrp/composites.jl\"","category":"page"},{"location":"generated/lrp/composites/#docs-composites","page":"Assigning rules to layers","title":"Assigning LRP rules to layers","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"In this example, we will show how to assign LRP rules to specific layers. For this purpose, we first define a small VGG-like convolutional neural network:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"using ExplainableAI\nusing Flux\n\nmodel = Chain(\n    Chain(\n        Conv((3, 3), 3 => 8, relu; pad=1),\n        Conv((3, 3), 8 => 8, relu; pad=1),\n        MaxPool((2, 2)),\n        Conv((3, 3), 8 => 16, relu; pad=1),\n        Conv((3, 3), 16 => 16, relu; pad=1),\n        MaxPool((2, 2)),\n    ),\n    Chain(\n        Flux.flatten,\n        Dense(1024 => 512, relu),\n        Dropout(0.5),\n        Dense(512 => 100, relu)\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/lrp/composites/#docs-composites-manual","page":"Assigning rules to layers","title":"Manually assigning rules","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"When creating an LRP-analyzer, we can assign individual rules to each layer. As we can see above, our model is a Chain of two Flux Chains. Using flatten_model, we can flatten the model into a single Chain:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"model_flat = flatten_model(model)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"This allows us to define an LRP analyzer using an array of rules matching the length of the Flux chain:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"rules = [\n    FlatRule(),\n    ZPlusRule(),\n    ZeroRule(),\n    ZPlusRule(),\n    ZPlusRule(),\n    ZeroRule(),\n    PassRule(),\n    EpsilonRule(),\n    PassRule(),\n    EpsilonRule(),\n];\nnothing #hide","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"The LRP analyzer will show a summary of how layers and rules got matched:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"LRP(model_flat, rules)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"However, this approach only works for models that can be fully flattened. For unflattened models and models containing Parallel layers, we can compose rules using ChainTuples and ParallelTuples which match the model structure:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"rules = ChainTuple(\n    ChainTuple(\n        FlatRule(),\n        ZPlusRule(),\n        ZeroRule(),\n        ZPlusRule(),\n        ZPlusRule(),\n        ZeroRule()\n    ),\n    ChainTuple(\n        PassRule(),\n        EpsilonRule(),\n        PassRule(),\n        EpsilonRule(),\n    ),\n)\n\nanalyzer = LRP(model, rules; flatten=false)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"note: Keyword argument `flatten`\nWe used the LRP keyword argument flatten=false to showcase that the structure of the model can be preserved. For performance reasons, the default flatten=true is recommended.","category":"page"},{"location":"generated/lrp/composites/#docs-composites-custom","page":"Assigning rules to layers","title":"Custom composites","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"Instead of manually defining a list of rules, we can also define a Composite. A composite constructs a list of LRP-rules by sequentially applying the composite primitives it contains.","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"To obtain the same set of rules as in the previous example, we can define","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"composite = Composite(\n    GlobalTypeMap( # the following maps of layer types to LRP rules are applied globally\n        Conv                 => ZPlusRule(),   # apply ZPlusRule on all Conv layers\n        Dense                => EpsilonRule(), # apply EpsilonRule on all Dense layers\n        Dropout              => PassRule(),    # apply PassRule on all Dropout layers\n        MaxPool              => ZeroRule(),    # apply ZeroRule on all MaxPool layers\n        typeof(Flux.flatten) => PassRule(),    # apply PassRule on all flatten layers\n    ),\n    FirstLayerMap( # the following rule is applied to the first layer\n        FlatRule()\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"We now construct an LRP analyzer from composite","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"analyzer = LRP(model, composite; flatten=false)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"As you can see, this analyzer contains the same rules as our previous one. To compute rules for a model without creating an analyzer, use lrp_rules:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"lrp_rules(model, composite)","category":"page"},{"location":"generated/lrp/composites/#Composite-primitives","page":"Assigning rules to layers","title":"Composite primitives","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"The following Composite primitives can used to construct a Composite.","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"To apply a single rule, use:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"LayerMap to apply a rule to a layer at a given index\nGlobalMap to apply a rule to all layers\nRangeMap to apply a rule to a positional range of layers\nFirstLayerMap to apply a rule to the first layer\nLastLayerMap to apply a rule to the last layer","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"To apply a set of rules to layers based on their type, use:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"GlobalTypeMap to apply a dictionary that maps layer types to LRP-rules\nRangeTypeMap for a TypeMap on generalized ranges\nFirstLayerTypeMap for a TypeMap on the first layer of a model\nLastLayerTypeMap for a TypeMap on the last layer\nFirstNTypeMap for a TypeMap on the first n layers","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"Primitives are called sequentially in the order the Composite was created with and overwrite rules specified by previous primitives.","category":"page"},{"location":"generated/lrp/composites/#Assigning-a-rule-to-a-specific-layer","page":"Assigning rules to layers","title":"Assigning a rule to a specific layer","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"To assign a rule to a specific layer, we can use LayerMap, which maps an LRP-rule to all layers in the model at the given index.","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"To display indices, use the show_layer_indices helper function:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"show_layer_indices(model)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"Let's demonstrate LayerMap by assigning a specific rule to the last Conv layer at index (1, 5):","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"composite = Composite(LayerMap((1, 5), EpsilonRule()))\n\nLRP(model, composite; flatten=false)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"This approach also works with Parallel layers.","category":"page"},{"location":"generated/lrp/composites/#docs-composites-presets","page":"Assigning rules to layers","title":"Composite presets","text":"","category":"section"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"ExplainableAI.jl provides a set of default composites. A list of all implemented default composites can be found in the API reference, e.g. the EpsilonPlusFlat composite:","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"composite = EpsilonPlusFlat()","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"analyzer = LRP(model, composite; flatten=false)","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"","category":"page"},{"location":"generated/lrp/composites/","page":"Assigning rules to layers","title":"Assigning rules to layers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"EditURL = \"../literate/heatmapping.jl\"","category":"page"},{"location":"generated/heatmapping/#docs-heatmapping","page":"Heatmapping","title":"Heatmapping","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Since numerical explanations are not very informative at first sight, we can visualize them by computing a heatmap. This page showcases different options and preset for heatmapping, building on the basics shown in the Getting started section.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"We start out by loading the same pre-trained LeNet5 model and MNIST input data:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"using ExplainableAI\nusing Flux\n\nusing BSON # hide\nmodel = BSON.load(\"../model.bson\", @__MODULE__)[:model] # hide\nmodel","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"using MLDatasets\nusing ImageCore, ImageIO, ImageShow\n\nindex = 10\nx, y = MNIST(Float32, :test)[10]\ninput = reshape(x, 28, 28, 1, :)\n\nconvert2image(MNIST, x)","category":"page"},{"location":"generated/heatmapping/#Automatic-heatmap-presets","page":"Heatmapping","title":"Automatic heatmap presets","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"The function heatmap automatically applies common presets for each method.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Since InputTimesGradient and LRP both compute attributions, their presets are similar. Gradient methods however are typically shown in grayscale:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"analyzer = Gradient(model)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"analyzer = InputTimesGradient(model)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/heatmapping/#Custom-heatmap-settings","page":"Heatmapping","title":"Custom heatmap settings","text":"","category":"section"},{"location":"generated/heatmapping/#Color-schemes","page":"Heatmapping","title":"Color schemes","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"We can partially or fully override presets by passing keyword arguments to heatmap. For example, we can use a custom color scheme from ColorSchemes.jl using the keyword argument cs:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"using ColorSchemes\n\nexpl = analyze(input, analyzer)\nheatmap(expl; cs=ColorSchemes.jet)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; cs=ColorSchemes.inferno)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Refer to the ColorSchemes.jl catalogue for a gallery of available color schemes.","category":"page"},{"location":"generated/heatmapping/#docs-heatmap-reduce","page":"Heatmapping","title":"Color channel reduction","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Explanations have the same dimensionality as the inputs to the classifier. For images with multiple color channels, this means that the explanation also has a \"color channel\" dimension.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"The keyword argument reduce can be used to reduce this dimension to a single scalar value for each pixel. The following presets are available:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":":sum: sum up color channels (default setting)\n:norm: compute 2-norm over the color channels\n:maxabs: compute maximum(abs, x) over the color channels","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; reduce=:sum)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; reduce=:norm)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; reduce=:maxabs)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Since MNIST only has a single color channel, there is no need for reduction and heatmaps look identical.","category":"page"},{"location":"generated/heatmapping/#docs-heatmap-rangescale","page":"Heatmapping","title":"Mapping explanations onto the color scheme","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"To map a color-channel-reduced explanation onto a color scheme, we first need to normalize all values to the range 0 1.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"For this purpose, two presets are available through the rangescale keyword argument:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":":extrema: normalize to the minimum and maximum value of the explanation\n:centered: normalize to the maximum absolute value of the explanation. Values of zero will be mapped to the center of the color scheme.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Depending on the color scheme, one of these presets may be more suitable than the other. The default color scheme for InputTimesGradient, seismic, is centered around zero, making :centered a good choice:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; rangescale=:centered)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; rangescale=:extrema)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"However, for the inferno color scheme, which is not centered around zero, :extrema leads to a heatmap with higher contrast.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; rangescale=:centered, cs=ColorSchemes.inferno)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmap(expl; rangescale=:extrema, cs=ColorSchemes.inferno)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"For the full list of heatmap keyword arguments, refer to the heatmap documentation.","category":"page"},{"location":"generated/heatmapping/#docs-heatmapping-batches","page":"Heatmapping","title":"Heatmapping batches","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Heatmapping also works with input batches. Let's demonstrate this by using a batch of 100 images from the MNIST dataset:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"xs, ys = MNIST(Float32, :test)[1:100]\nbatch = reshape(xs, 28, 28, 1, :); # reshape to WHCN format\nnothing #hide","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"The heatmap function automatically recognizes that the explanation is batched and returns a Vector of images:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"heatmaps = heatmap(batch, analyzer)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Image.jl's mosaic function can used to display them in a grid:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"mosaic(heatmaps; nrow=10)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"note: Output type consistency\nTo obtain a singleton Vector containing a single heatmap for non-batched inputs, use the heatmap keyword argument unpack_singleton=false.","category":"page"},{"location":"generated/heatmapping/#Processing-heatmaps","page":"Heatmapping","title":"Processing heatmaps","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Heatmapping makes use of the Julia-based image processing ecosystem Images.jl.","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"If you want to further process heatmaps, you may benefit from reading about some fundamental conventions that the ecosystem utilizes that are different from how images are typically represented in OpenCV, MATLAB, ImageJ or Python.","category":"page"},{"location":"generated/heatmapping/#Saving-heatmaps","page":"Heatmapping","title":"Saving heatmaps","text":"","category":"section"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"Since heatmaps are regular Images.jl images, they can be saved as such:","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"using FileIO\n\nimg = heatmap(input, analyzer)\nsave(\"heatmap.png\", img)","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"","category":"page"},{"location":"generated/heatmapping/","page":"Heatmapping","title":"Heatmapping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lrp/api/#LRP-analyzer","page":"LRP","title":"LRP analyzer","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"Refer to LRP for documentation on the LRP analyzer.","category":"page"},{"location":"lrp/api/#api-lrp-rules","page":"LRP","title":"LRP rules","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"ZeroRule\nEpsilonRule\nGammaRule\nWSquareRule\nFlatRule\nAlphaBetaRule\nZPlusRule\nZBoxRule\nPassRule\nGeneralizedGammaRule","category":"page"},{"location":"lrp/api/#ExplainableAI.ZeroRule","page":"LRP","title":"ExplainableAI.ZeroRule","text":"ZeroRule()\n\nLRP-0 rule. Commonly used on upper layers.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_i fracW_ija_j^ksum_l W_ila_l^k+b_i R_i^k+1\n\nReferences\n\nS. Bach et al., On Pixel-Wise Explanations for Non-Linear Classifier Decisions by Layer-Wise Relevance Propagation\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.EpsilonRule","page":"LRP","title":"ExplainableAI.EpsilonRule","text":"EpsilonRule([epsilon=1.0e-6])\n\nLRP-ϵ rule. Commonly used on middle layers.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifracW_ija_j^kepsilon +sum_lW_ila_l^k+b_i R_i^k+1\n\nOptional arguments\n\nepsilon: Optional stabilization parameter, defaults to 1.0e-6.\n\nReferences\n\nS. Bach et al., On Pixel-Wise Explanations for Non-Linear Classifier Decisions by Layer-Wise Relevance Propagation\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.GammaRule","page":"LRP","title":"ExplainableAI.GammaRule","text":"GammaRule([gamma=0.25])\n\nLRP-γ rule. Commonly used on lower layers.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifrac(W_ij+gamma W_ij^+)a_j^k\n    sum_l(W_il+gamma W_il^+)a_l^k+(b_i+gamma b_i^+) R_i^k+1\n\nOptional arguments\n\ngamma: Optional multiplier for added positive weights, defaults to 0.25.\n\nReferences\n\nG. Montavon et al., Layer-Wise Relevance Propagation: An Overview\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.WSquareRule","page":"LRP","title":"ExplainableAI.WSquareRule","text":"WSquareRule()\n\nLRP-w² rule. Commonly used on the first layer when values are unbounded.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifracW_ij^2sum_l W_il^2 R_i^k+1\n\nReferences\n\nG. Montavon et al., Explaining Nonlinear Classification Decisions with Deep Taylor Decomposition\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.FlatRule","page":"LRP","title":"ExplainableAI.FlatRule","text":"FlatRule()\n\nLRP-Flat rule. Similar to the WSquareRule, but with all weights set to one and all bias terms set to zero.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifrac1sum_l 1 R_i^k+1 = sum_ifrac1n_i R_i^k+1\n\nwhere n_i is the number of input neurons connected to the output neuron at index i.\n\nReferences\n\nS. Lapuschkin et al., Unmasking Clever Hans predictors and assessing what machines really learn\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.AlphaBetaRule","page":"LRP","title":"ExplainableAI.AlphaBetaRule","text":"AlphaBetaRule([alpha=2.0, beta=1.0])\n\nLRP-αβ rule. Weights positive and negative contributions according to the parameters alpha and beta respectively. The difference α-β must be equal to one. Commonly used on lower layers.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ileft(\n    alphafracleft(W_ija_j^kright)^+sum_lleft(W_ila_l^k+b_iright)^+\n    -betafracleft(W_ija_j^kright)^-sum_lleft(W_ila_l^k+b_iright)^-\nright) R_i^k+1\n\nOptional arguments\n\nalpha: Multiplier for the positive output term, defaults to 2.0.\nbeta: Multiplier for the negative output term, defaults to 1.0.\n\nReferences\n\nS. Bach et al., On Pixel-Wise Explanations for Non-Linear Classifier Decisions by Layer-Wise Relevance Propagation\nG. Montavon et al., Layer-Wise Relevance Propagation: An Overview\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.ZPlusRule","page":"LRP","title":"ExplainableAI.ZPlusRule","text":"ZPlusRule()\n\nLRP-z rule. Commonly used on lower layers.\n\nEquivalent to AlphaBetaRule(1.0f0, 0.0f0), but slightly faster. See also AlphaBetaRule.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifracleft(W_ija_j^kright)^+sum_lleft(W_ila_l^k+b_iright)^+ R_i^k+1\n\nReferences\n\nS. Bach et al., On Pixel-Wise Explanations for Non-Linear Classifier Decisions by Layer-Wise Relevance Propagation\nG. Montavon et al., Explaining Nonlinear Classification Decisions with Deep Taylor Decomposition\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.ZBoxRule","page":"LRP","title":"ExplainableAI.ZBoxRule","text":"ZBoxRule(low, high)\n\nLRP-zᴮ-rule. Commonly used on the first layer for pixel input.\n\nThe parameters low and high should be set to the lower and upper bounds of the input features, e.g. 0.0 and 1.0 for raw image data. It is also possible to provide two arrays of that match the input size.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k=sum_i fracW_ija_j^k - W_ij^+l_j - W_ij^-h_j\n    sum_l W_ila_l^k+b_i - left(W_il^+l_l+b_i^+right) - left(W_il^-h_l+b_i^-right) R_i^k+1\n\nReferences\n\nG. Montavon et al., Layer-Wise Relevance Propagation: An Overview\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.PassRule","page":"LRP","title":"ExplainableAI.PassRule","text":"PassRule()\n\nPass-through rule. Passes relevance through to the lower layer.\n\nSupports layers with constant input and output shapes, e.g. reshaping layers.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = R_j^k+1\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.GeneralizedGammaRule","page":"LRP","title":"ExplainableAI.GeneralizedGammaRule","text":"GeneralizedGammaRule([gamma=0.25])\n\nGeneralized LRP-γ rule. Can be used on layers with leakyrelu activation functions.\n\nDefinition\n\nPropagates relevance R^k+1 at layer output to R^k at layer input according to\n\nR_j^k = sum_ifrac\n    (W_ij+gamma W_ij^+)a_j^+ +(W_ij+gamma W_ij^-)a_j^-\n    sum_l(W_il+gamma W_il^+)a_j^+ +(W_il+gamma W_il^-)a_j^- +(b_i+gamma b_i^+)\nI(z_k0) cdot R^k+1_i\n+sum_ifrac\n    (W_ij+gamma W_ij^-)a_j^+ +(W_ij+gamma W_ij^+)a_j^-\n    sum_l(W_il+gamma W_il^-)a_j^+ +(W_il+gamma W_il^+)a_j^- +(b_i+gamma b_i^-)\nI(z_k0) cdot R^k+1_i\n\nOptional arguments\n\ngamma: Optional multiplier for added positive weights, defaults to 0.25.\n\nReferences\n\nL. Andéol et al., Learning Domain Invariant Representations by Joint Wasserstein Distance Minimization\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"For manual rule assignment,  use ChainTuple and ParallelTuple, matching the model structure:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"ChainTuple\nParallelTuple","category":"page"},{"location":"lrp/api/#ExplainableAI.ChainTuple","page":"LRP","title":"ExplainableAI.ChainTuple","text":"ChainTuple(xs)\n\nThin wrapper around Tuple for use with Flux.jl models.\n\nCombining ChainTuple and ParallelTuple, data xs can be stored while preserving the structure of a Flux model without risking type piracy.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.ParallelTuple","page":"LRP","title":"ExplainableAI.ParallelTuple","text":"ParallelTuple(xs)\n\nThin wrapper around Tuple for use with Flux.jl models.\n\nCombining ChainTuple and ParallelTuple, data xs can be stored while preserving the structure of a Flux model without risking type piracy.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#Composites","page":"LRP","title":"Composites","text":"","category":"section"},{"location":"lrp/api/#Applying-composites","page":"LRP","title":"Applying composites","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"Composite\nlrp_rules","category":"page"},{"location":"lrp/api/#ExplainableAI.Composite","page":"LRP","title":"ExplainableAI.Composite","text":"Composite(primitives...)\nComposite(default_rule, primitives...)\n\nAutomatically contructs a list of LRP-rules by sequentially applying composite primitives.\n\nPrimitives\n\nTo apply a single rule, use:\n\nLayerMap to apply a rule to the n-th layer of a model\nGlobalMap to apply a rule to all layers\nRangeMap to apply a rule to a positional range of layers\nFirstLayerMap to apply a rule to the first layer\nLastLayerMap to apply a rule to the last layer\n\nTo apply a set of rules to layers based on their type, use:\n\nGlobalTypeMap to apply a dictionary that maps layer types to LRP-rules\nRangeTypeMap for a TypeMap on generalized ranges\nFirstLayerTypeMap for a TypeMap on the first layer of a model\nLastLayerTypeMap for a TypeMap on the last layer\nFirstNTypeMap for a TypeMap on the first n layers\n\nExample\n\nUsing a VGG11 model:\n\njulia> composite = Composite(\n           GlobalTypeMap(\n               ConvLayer => AlphaBetaRule(),\n               Dense => EpsilonRule(),\n               PoolingLayer => EpsilonRule(),\n               DropoutLayer => PassRule(),\n               ReshapingLayer => PassRule(),\n           ),\n           FirstNTypeMap(7, Conv => FlatRule()),\n       );\n\njulia> analyzer = LRP(model, composite)\nLRP(\n  Conv((3, 3), 3 => 64, relu, pad=1)    => FlatRule(),\n  MaxPool((2, 2))                       => EpsilonRule{Float32}(1.0f-6),\n  Conv((3, 3), 64 => 128, relu, pad=1)  => FlatRule(),\n  MaxPool((2, 2))                       => EpsilonRule{Float32}(1.0f-6),\n  Conv((3, 3), 128 => 256, relu, pad=1) => FlatRule(),\n  Conv((3, 3), 256 => 256, relu, pad=1) => FlatRule(),\n  MaxPool((2, 2))                       => EpsilonRule{Float32}(1.0f-6),\n  Conv((3, 3), 256 => 512, relu, pad=1) => AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n  Conv((3, 3), 512 => 512, relu, pad=1) => AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n  MaxPool((2, 2))                       => EpsilonRule{Float32}(1.0f-6),\n  Conv((3, 3), 512 => 512, relu, pad=1) => AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n  Conv((3, 3), 512 => 512, relu, pad=1) => AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n  MaxPool((2, 2))                       => EpsilonRule{Float32}(1.0f-6),\n  MLUtils.flatten                       => PassRule(),\n  Dense(25088 => 4096, relu)            => EpsilonRule{Float32}(1.0f-6),\n  Dropout(0.5)                          => PassRule(),\n  Dense(4096 => 4096, relu)             => EpsilonRule{Float32}(1.0f-6),\n  Dropout(0.5)                          => PassRule(),\n  Dense(4096 => 1000)                   => EpsilonRule{Float32}(1.0f-6),\n)\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.lrp_rules","page":"LRP","title":"ExplainableAI.lrp_rules","text":"lrp_rules(model, composite)\n\nApply a composite to obtain LRP-rules for a given Flux model.\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#api-composite-primitives","page":"LRP","title":"Composite primitives","text":"","category":"section"},{"location":"lrp/api/#Mapping-layers-to-rules","page":"LRP","title":"Mapping layers to rules","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"Composite primitives that apply a single rule:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"LayerMap\nGlobalMap\nRangeMap\nFirstLayerMap\nLastLayerMap","category":"page"},{"location":"lrp/api/#ExplainableAI.LayerMap","page":"LRP","title":"ExplainableAI.LayerMap","text":"LayerMap(index, rule)\n\nComposite primitive that maps an LRP-rule to all layers in the model at the given index. The index can either be an integer or a tuple of integers to map a rule to a specific layer in nested Flux Chains.\n\nSee show_layer_indices to print layer indices and Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.GlobalMap","page":"LRP","title":"ExplainableAI.GlobalMap","text":"GlobalMap(rule)\n\nComposite primitive that maps an LRP-rule to all layers in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.RangeMap","page":"LRP","title":"ExplainableAI.RangeMap","text":"RangeMap(range, rule)\n\nComposite primitive that maps an LRP-rule to the specified positional range of layers in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.FirstLayerMap","page":"LRP","title":"ExplainableAI.FirstLayerMap","text":"FirstLayerMap(rule)\n\nComposite primitive that maps an LRP-rule to the first layer in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.LastLayerMap","page":"LRP","title":"ExplainableAI.LastLayerMap","text":"LastLayerMap(rule)\n\nComposite primitive that maps an LRP-rule to the last layer in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"To apply LayerMap to nested Flux Chains or Parallel layers,  make use of show_layer_indices:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"show_layer_indices","category":"page"},{"location":"lrp/api/#ExplainableAI.show_layer_indices","page":"LRP","title":"ExplainableAI.show_layer_indices","text":"show_layer_indices(model)\n\nPrint layer indices of Flux models. This is primarily a utility to help define LayerMap primitives.\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#Mapping-layers-to-rules-based-on-type","page":"LRP","title":"Mapping layers to rules based on type","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"Composite primitives that apply rules based on the layer type:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"GlobalTypeMap\nRangeTypeMap\nFirstLayerTypeMap\nLastLayerTypeMap\nFirstNTypeMap","category":"page"},{"location":"lrp/api/#ExplainableAI.GlobalTypeMap","page":"LRP","title":"ExplainableAI.GlobalTypeMap","text":"GlobalTypeMap(map)\n\nComposite primitive that maps layer types to LRP rules based on a list of type-rule-pairs map.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.RangeTypeMap","page":"LRP","title":"ExplainableAI.RangeTypeMap","text":"RangeTypeMap(range, map)\n\nComposite primitive that maps layer types to LRP rules based on a list of type-rule-pairs map within the specified range of layers in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.FirstLayerTypeMap","page":"LRP","title":"ExplainableAI.FirstLayerTypeMap","text":"FirstLayerTypeMap(map)\n\nComposite primitive that maps the type of the first layer of the model to LRP rules based on a list of type-rule-pairs map.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.LastLayerTypeMap","page":"LRP","title":"ExplainableAI.LastLayerTypeMap","text":"LastLayerTypeMap(map)\n\nComposite primitive that maps the type of the last layer of the model to LRP rules based on a list of type-rule-pairs map.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.FirstNTypeMap","page":"LRP","title":"ExplainableAI.FirstNTypeMap","text":"FirstNTypeMap(n, map)\n\nComposite primitive that maps layer types to LRP rules based on a list of type-rule-pairs map within the first n layers in the model.\n\nSee Composite for an example.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#Union-types-for-composites","page":"LRP","title":"Union types for composites","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"The following exported union types types can be used to define TypeMaps:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"ConvLayer\nPoolingLayer\nDropoutLayer\nReshapingLayer\nNormalizationLayer","category":"page"},{"location":"lrp/api/#ExplainableAI.ConvLayer","page":"LRP","title":"ExplainableAI.ConvLayer","text":"Union type for convolutional layers.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.PoolingLayer","page":"LRP","title":"ExplainableAI.PoolingLayer","text":"Union type for pooling layers.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.DropoutLayer","page":"LRP","title":"ExplainableAI.DropoutLayer","text":"Union type for dropout layers.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.ReshapingLayer","page":"LRP","title":"ExplainableAI.ReshapingLayer","text":"Union type for reshaping layers such as flatten.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#ExplainableAI.NormalizationLayer","page":"LRP","title":"ExplainableAI.NormalizationLayer","text":"Union type for normalization layers.\n\n\n\n\n\n","category":"type"},{"location":"lrp/api/#api-composite-presets","page":"LRP","title":"Composite presets","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"EpsilonGammaBox\nEpsilonPlus\nEpsilonAlpha2Beta1\nEpsilonPlusFlat\nEpsilonAlpha2Beta1Flat","category":"page"},{"location":"lrp/api/#ExplainableAI.EpsilonGammaBox","page":"LRP","title":"ExplainableAI.EpsilonGammaBox","text":"EpsilonGammaBox(low, high; [epsilon=1.0f-6, gamma=0.25f0])\n\nComposite using the following primitives:\n\njulia> EpsilonGammaBox(-3.0f0, 3.0f0)\nComposite(\n  GlobalTypeMap(  # all layers\n    Flux.Conv               => ExplainableAI.GammaRule{Float32}(0.25f0),\n    Flux.ConvTranspose      => ExplainableAI.GammaRule{Float32}(0.25f0),\n    Flux.CrossCor           => ExplainableAI.GammaRule{Float32}(0.25f0),\n    Flux.Dense              => ExplainableAI.EpsilonRule{Float32}(1.0f-6),\n    typeof(NNlib.dropout)   => ExplainableAI.PassRule(),\n    Flux.AlphaDropout       => ExplainableAI.PassRule(),\n    Flux.Dropout            => ExplainableAI.PassRule(),\n    Flux.BatchNorm          => ExplainableAI.PassRule(),\n    typeof(Flux.flatten)    => ExplainableAI.PassRule(),\n    typeof(MLUtils.flatten) => ExplainableAI.PassRule(),\n    typeof(identity)        => ExplainableAI.PassRule(),\n ),\n  FirstLayerTypeMap(  # first layer\n    Flux.Conv          => ExplainableAI.ZBoxRule{Float32}(-3.0f0, 3.0f0),\n    Flux.ConvTranspose => ExplainableAI.ZBoxRule{Float32}(-3.0f0, 3.0f0),\n    Flux.CrossCor      => ExplainableAI.ZBoxRule{Float32}(-3.0f0, 3.0f0),\n ),\n)\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.EpsilonPlus","page":"LRP","title":"ExplainableAI.EpsilonPlus","text":"EpsilonPlus(; [epsilon=1.0f-6])\n\nComposite using the following primitives:\n\njulia> EpsilonPlus()\nComposite(\n  GlobalTypeMap(  # all layers\n    Flux.Conv               => ExplainableAI.ZPlusRule(),\n    Flux.ConvTranspose      => ExplainableAI.ZPlusRule(),\n    Flux.CrossCor           => ExplainableAI.ZPlusRule(),\n    Flux.Dense              => ExplainableAI.EpsilonRule{Float32}(1.0f-6),\n    typeof(NNlib.dropout)   => ExplainableAI.PassRule(),\n    Flux.AlphaDropout       => ExplainableAI.PassRule(),\n    Flux.Dropout            => ExplainableAI.PassRule(),\n    Flux.BatchNorm          => ExplainableAI.PassRule(),\n    typeof(Flux.flatten)    => ExplainableAI.PassRule(),\n    typeof(MLUtils.flatten) => ExplainableAI.PassRule(),\n    typeof(identity)        => ExplainableAI.PassRule(),\n ),\n)\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.EpsilonAlpha2Beta1","page":"LRP","title":"ExplainableAI.EpsilonAlpha2Beta1","text":"EpsilonAlpha2Beta1(; [epsilon=1.0f-6])\n\nComposite using the following primitives:\n\njulia> EpsilonAlpha2Beta1()\nComposite(\n  GlobalTypeMap(  # all layers\n    Flux.Conv               => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.ConvTranspose      => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.CrossCor           => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.Dense              => ExplainableAI.EpsilonRule{Float32}(1.0f-6),\n    typeof(NNlib.dropout)   => ExplainableAI.PassRule(),\n    Flux.AlphaDropout       => ExplainableAI.PassRule(),\n    Flux.Dropout            => ExplainableAI.PassRule(),\n    Flux.BatchNorm          => ExplainableAI.PassRule(),\n    typeof(Flux.flatten)    => ExplainableAI.PassRule(),\n    typeof(MLUtils.flatten) => ExplainableAI.PassRule(),\n    typeof(identity)        => ExplainableAI.PassRule(),\n ),\n)\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.EpsilonPlusFlat","page":"LRP","title":"ExplainableAI.EpsilonPlusFlat","text":"EpsilonPlusFlat(; [epsilon=1.0f-6])\n\nComposite using the following primitives:\n\njulia> EpsilonPlusFlat()\nComposite(\n  GlobalTypeMap(  # all layers\n    Flux.Conv               => ExplainableAI.ZPlusRule(),\n    Flux.ConvTranspose      => ExplainableAI.ZPlusRule(),\n    Flux.CrossCor           => ExplainableAI.ZPlusRule(),\n    Flux.Dense              => ExplainableAI.EpsilonRule{Float32}(1.0f-6),\n    typeof(NNlib.dropout)   => ExplainableAI.PassRule(),\n    Flux.AlphaDropout       => ExplainableAI.PassRule(),\n    Flux.Dropout            => ExplainableAI.PassRule(),\n    Flux.BatchNorm          => ExplainableAI.PassRule(),\n    typeof(Flux.flatten)    => ExplainableAI.PassRule(),\n    typeof(MLUtils.flatten) => ExplainableAI.PassRule(),\n    typeof(identity)        => ExplainableAI.PassRule(),\n ),\n  FirstLayerTypeMap(  # first layer\n    Flux.Conv          => ExplainableAI.FlatRule(),\n    Flux.ConvTranspose => ExplainableAI.FlatRule(),\n    Flux.CrossCor      => ExplainableAI.FlatRule(),\n    Flux.Dense         => ExplainableAI.FlatRule(),\n ),\n)\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.EpsilonAlpha2Beta1Flat","page":"LRP","title":"ExplainableAI.EpsilonAlpha2Beta1Flat","text":"EpsilonAlpha2Beta1Flat(; [epsilon=1.0f-6])\n\nComposite using the following primitives:\n\njulia> EpsilonAlpha2Beta1Flat()\nComposite(\n  GlobalTypeMap(  # all layers\n    Flux.Conv               => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.ConvTranspose      => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.CrossCor           => ExplainableAI.AlphaBetaRule{Float32}(2.0f0, 1.0f0),\n    Flux.Dense              => ExplainableAI.EpsilonRule{Float32}(1.0f-6),\n    typeof(NNlib.dropout)   => ExplainableAI.PassRule(),\n    Flux.AlphaDropout       => ExplainableAI.PassRule(),\n    Flux.Dropout            => ExplainableAI.PassRule(),\n    Flux.BatchNorm          => ExplainableAI.PassRule(),\n    typeof(Flux.flatten)    => ExplainableAI.PassRule(),\n    typeof(MLUtils.flatten) => ExplainableAI.PassRule(),\n    typeof(identity)        => ExplainableAI.PassRule(),\n ),\n  FirstLayerTypeMap(  # first layer\n    Flux.Conv          => ExplainableAI.FlatRule(),\n    Flux.ConvTranspose => ExplainableAI.FlatRule(),\n    Flux.CrossCor      => ExplainableAI.FlatRule(),\n    Flux.Dense         => ExplainableAI.FlatRule(),\n ),\n)\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#Custom-rules","page":"LRP","title":"Custom rules","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"These utilities can be used to define custom rules without writing boilerplate code. To extend these functions, explicitly import them: ","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"ExplainableAI.modify_input\nExplainableAI.modify_denominator\nExplainableAI.modify_parameters\nExplainableAI.modify_weight\nExplainableAI.modify_bias\nExplainableAI.modify_layer\nExplainableAI.is_compatible","category":"page"},{"location":"lrp/api/#ExplainableAI.modify_input","page":"LRP","title":"ExplainableAI.modify_input","text":"modify_input(rule, input)\n\nModify input activation before computing relevance propagation.\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.modify_denominator","page":"LRP","title":"ExplainableAI.modify_denominator","text":"modify_denominator(rule, d)\n\nModify denominator z for numerical stability on the forward pass.\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.modify_parameters","page":"LRP","title":"ExplainableAI.modify_parameters","text":"modify_parameters(rule, parameter)\n\nModify parameters before computing the relevance.\n\nNote\n\nUse of a custom function modify_layer will overwrite functionality of modify_parameters, modify_weight and modify_bias for the implemented combination of rule and layer types. This is due to the fact that internally, modify_weight and modify_bias are called by the default implementation of modify_layer. modify_weight and modify_bias in turn call modify_parameters by default.\n\nThe default call structure looks as follows:\n\n┌─────────────────────────────────────────┐\n│              modify_layer               │\n└─────────┬─────────────────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│   modify_weight   │ │    modify_bias    │\n└─────────┬─────────┘ └─────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│ modify_parameters │ │ modify_parameters │\n└───────────────────┘ └───────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.modify_weight","page":"LRP","title":"ExplainableAI.modify_weight","text":"modify_weight(rule, weight)\n\nModify layer weights before computing the relevance.\n\nNote\n\nUse of a custom function modify_layer will overwrite functionality of modify_parameters, modify_weight and modify_bias for the implemented combination of rule and layer types. This is due to the fact that internally, modify_weight and modify_bias are called by the default implementation of modify_layer. modify_weight and modify_bias in turn call modify_parameters by default.\n\nThe default call structure looks as follows:\n\n┌─────────────────────────────────────────┐\n│              modify_layer               │\n└─────────┬─────────────────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│   modify_weight   │ │    modify_bias    │\n└─────────┬─────────┘ └─────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│ modify_parameters │ │ modify_parameters │\n└───────────────────┘ └───────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.modify_bias","page":"LRP","title":"ExplainableAI.modify_bias","text":"modify_bias(rule, bias)\n\nModify layer bias before computing the relevance.\n\nNote\n\nUse of a custom function modify_layer will overwrite functionality of modify_parameters, modify_weight and modify_bias for the implemented combination of rule and layer types. This is due to the fact that internally, modify_weight and modify_bias are called by the default implementation of modify_layer. modify_weight and modify_bias in turn call modify_parameters by default.\n\nThe default call structure looks as follows:\n\n┌─────────────────────────────────────────┐\n│              modify_layer               │\n└─────────┬─────────────────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│   modify_weight   │ │    modify_bias    │\n└─────────┬─────────┘ └─────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│ modify_parameters │ │ modify_parameters │\n└───────────────────┘ └───────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.modify_layer","page":"LRP","title":"ExplainableAI.modify_layer","text":"modify_layer(rule, layer)\n\nModify layer before computing the relevance.\n\nNote\n\nUse of a custom function modify_layer will overwrite functionality of modify_parameters, modify_weight and modify_bias for the implemented combination of rule and layer types. This is due to the fact that internally, modify_weight and modify_bias are called by the default implementation of modify_layer. modify_weight and modify_bias in turn call modify_parameters by default.\n\nThe default call structure looks as follows:\n\n┌─────────────────────────────────────────┐\n│              modify_layer               │\n└─────────┬─────────────────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│   modify_weight   │ │    modify_bias    │\n└─────────┬─────────┘ └─────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│ modify_parameters │ │ modify_parameters │\n└───────────────────┘ └───────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.is_compatible","page":"LRP","title":"ExplainableAI.is_compatible","text":"is_compatible(rule, layer)\n\nCheck compatibility of a LRP-Rule with layer type.\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"Compatibility settings:","category":"page"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"LRP_CONFIG.supports_layer\nLRP_CONFIG.supports_activation","category":"page"},{"location":"lrp/api/#ExplainableAI.LRP_CONFIG.supports_layer","page":"LRP","title":"ExplainableAI.LRP_CONFIG.supports_layer","text":"LRP_CONFIG.supports_layer(layer)\n\nCheck whether LRP can be used on a layer or a Chain. To extend LRP to your own layers, define:\n\nLRP_CONFIG.supports_layer(::MyLayer) = true          # for structs\nLRP_CONFIG.supports_layer(::typeof(mylayer)) = true  # for functions\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#ExplainableAI.LRP_CONFIG.supports_activation","page":"LRP","title":"ExplainableAI.LRP_CONFIG.supports_activation","text":"LRP_CONFIG.supports_activation(σ)\n\nCheck whether LRP can be used on a given activation function. To extend LRP to your own activation functions, define:\n\nLRP_CONFIG.supports_activation(::typeof(myactivation)) = true  # for functions\nLRP_CONFIG.supports_activation(::MyActivation) = true          # for structs\n\n\n\n\n\n","category":"function"},{"location":"lrp/api/#Index","page":"LRP","title":"Index","text":"","category":"section"},{"location":"lrp/api/","page":"LRP","title":"LRP","text":"","category":"page"},{"location":"api/#Basic-API","page":"General","title":"Basic API","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"All methods in ExplainableAI.jl work by calling analyze on an input and an analyzer:","category":"page"},{"location":"api/","page":"General","title":"General","text":"analyze\nExplanation\nheatmap","category":"page"},{"location":"api/#ExplainableAI.analyze","page":"General","title":"ExplainableAI.analyze","text":"analyze(input, method)\nanalyze(input, method, neuron_selection)\n\nApply the analyzer method for the given input, returning an Explanation. If neuron_selection is specified, the explanation will be calculated for that neuron. Otherwise, the output neuron with the highest activation is automatically chosen.\n\nSee also Explanation and heatmap.\n\nKeyword arguments\n\nadd_batch_dim: add batch dimension to the input without allocating. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/#ExplainableAI.Explanation","page":"General","title":"ExplainableAI.Explanation","text":"Return type of analyzers when calling analyze.\n\nFields\n\nval: numerical output of the analyzer, e.g. an attribution or gradient\noutput: model output for the given analyzer input\nneuron_selection: neuron index used for the explanation\nanalyzer: symbol corresponding the used analyzer, e.g. :LRP or :Gradient\nextras: optional named tuple that can be used by analyzers   to return additional information.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExplainableAI.heatmap","page":"General","title":"ExplainableAI.heatmap","text":"heatmap(explanation)\nheatmap(input, analyzer)\nheatmap(input, analyzer, neuron_selection)\n\nVisualize explanation. Assumes Flux's WHCN convention (width, height, color channels, batch size).\n\nSee also analyze.\n\nKeyword arguments\n\ncs::ColorScheme: color scheme from ColorSchemes.jl that is applied.   When calling heatmap with an Explanation or analyzer, the method default is selected.   When calling heatmap with an array, the default is ColorSchemes.seismic.\nreduce::Symbol: selects how color channels are reduced to a single number to apply a color scheme.   The following methods can be selected, which are then applied over the color channels   for each \"pixel\" in the explanation:\n:sum: sum up color channels\n:norm: compute 2-norm over the color channels\n:maxabs: compute maximum(abs, x) over the color channels\nWhen calling heatmap with an Explanation or analyzer, the method default is selected.   When calling heatmap with an array, the default is :sum.\nrangescale::Symbol: selects how the color channel reduced heatmap is normalized   before the color scheme is applied. Can be either :extrema or :centered.   When calling heatmap with an Explanation or analyzer, the method default is selected.   When calling heatmap with an array, the default for use with the seismic color scheme is :centered.\npermute::Bool: Whether to flip W&H input channels. Default is true.\nunpack_singleton::Bool: When heatmapping a batch with a single sample, setting unpack_singleton=true   will return an image instead of an Vector containing a single image.\n\nNote: keyword arguments can't be used when calling heatmap with an analyzer.\n\n\n\n\n\n","category":"function"},{"location":"api/#Analyzers","page":"General","title":"Analyzers","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"LRP\nGradient\nInputTimesGradient\nSmoothGrad\nIntegratedGradients","category":"page"},{"location":"api/#ExplainableAI.LRP","page":"General","title":"ExplainableAI.LRP","text":"LRP(model, rules)\nLRP(model, composite)\n\nAnalyze model by applying Layer-Wise Relevance Propagation. The analyzer can either be created by passing an array of LRP-rules or by passing a composite, see Composite for an example.\n\nKeyword arguments\n\nskip_checks::Bool: Skip checks whether model is compatible with LRP and contains output softmax. Default is false.\nverbose::Bool: Select whether the model checks should print a summary on failure. Default is true.\n\nReferences\n\n[1] G. Montavon et al., Layer-Wise Relevance Propagation: An Overview [2] W. Samek et al., Explaining Deep Neural Networks and Beyond: A Review of Methods and Applications\n\n\n\n\n\n","category":"type"},{"location":"api/#ExplainableAI.Gradient","page":"General","title":"ExplainableAI.Gradient","text":"Gradient(model)\n\nAnalyze model by calculating the gradient of a neuron activation with respect to the input.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExplainableAI.InputTimesGradient","page":"General","title":"ExplainableAI.InputTimesGradient","text":"InputTimesGradient(model)\n\nAnalyze model by calculating the gradient of a neuron activation with respect to the input. This gradient is then multiplied element-wise with the input.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExplainableAI.SmoothGrad","page":"General","title":"ExplainableAI.SmoothGrad","text":"SmoothGrad(analyzer, [n=50, std=0.1, rng=GLOBAL_RNG])\nSmoothGrad(analyzer, [n=50, distribution=Normal(0, σ²=0.01), rng=GLOBAL_RNG])\n\nAnalyze model by calculating a smoothed sensitivity map. This is done by averaging sensitivity maps of a Gradient analyzer over random samples in a neighborhood of the input, typically by adding Gaussian noise with mean 0.\n\nReferences\n\nSmilkov et al., SmoothGrad: removing noise by adding noise\n\n\n\n\n\n","category":"function"},{"location":"api/#ExplainableAI.IntegratedGradients","page":"General","title":"ExplainableAI.IntegratedGradients","text":"IntegratedGradients(analyzer, [n=50])\nIntegratedGradients(analyzer, [n=50])\n\nAnalyze model by using the Integrated Gradients method.\n\nReferences\n\nSundararajan et al., Axiomatic Attribution for Deep Networks\n\n\n\n\n\n","category":"function"},{"location":"api/#Input-augmentations","page":"General","title":"Input augmentations","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"SmoothGrad and IntegratedGradients are special cases of the input augmentations  NoiseAugmentation and InterpolationAugmentation,  which can be applied as a wrapper to any analyzer:","category":"page"},{"location":"api/","page":"General","title":"General","text":"NoiseAugmentation\nInterpolationAugmentation","category":"page"},{"location":"api/#ExplainableAI.NoiseAugmentation","page":"General","title":"ExplainableAI.NoiseAugmentation","text":"NoiseAugmentation(analyzer, n, [std=1, rng=GLOBAL_RNG])\nNoiseAugmentation(analyzer, n, distribution, [rng=GLOBAL_RNG])\n\nA wrapper around analyzers that augments the input with n samples of additive noise sampled from distribution. This input augmentation is then averaged to return an Explanation.\n\n\n\n\n\n","category":"type"},{"location":"api/#ExplainableAI.InterpolationAugmentation","page":"General","title":"ExplainableAI.InterpolationAugmentation","text":"InterpolationAugmentation(model, [n=50])\n\nA wrapper around analyzers that augments the input with n steps of linear interpolation between the input and a reference input (typically zero(input)). The gradients w.r.t. this augmented input are then averaged and multiplied with the difference between the input and the reference input.\n\n\n\n\n\n","category":"type"},{"location":"api/#Model-preparation","page":"General","title":"Model preparation","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"strip_softmax\ncanonize\nflatten_model","category":"page"},{"location":"api/#ExplainableAI.strip_softmax","page":"General","title":"ExplainableAI.strip_softmax","text":"strip_softmax(model)\nstrip_softmax(layer)\n\nRemove softmax activation on layer or model if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#ExplainableAI.canonize","page":"General","title":"ExplainableAI.canonize","text":"canonize(model)\n\nCanonize model by flattening it and fusing BatchNorm layers into preceding Dense and Conv layers with linear activation functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#ExplainableAI.flatten_model","page":"General","title":"ExplainableAI.flatten_model","text":"flatten_model(model)\n\nFlatten a Flux Chain containing Chains.\n\n\n\n\n\n","category":"function"},{"location":"api/#Input-preprocessing","page":"General","title":"Input preprocessing","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"preprocess_imagenet","category":"page"},{"location":"api/#ExplainableAI.preprocess_imagenet","page":"General","title":"ExplainableAI.preprocess_imagenet","text":"preprocess_imagenet(img)\n\nPreprocess an image for use with Metalhead.jl's ImageNet models using PyTorch weights. Uses PyTorch's normalization constants.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"General","title":"Index","text":"","category":"section"},{"location":"api/","page":"General","title":"General","text":"","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"EditURL = \"../literate/augmentations.jl\"","category":"page"},{"location":"generated/augmentations/#docs-augmentations","page":"Input augmentations","title":"Analyzer augmentations","text":"","category":"section"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"All analyzers implemented in ExplainableAI.jl can be augmented by two types of augmentations: NoiseAugmentations and InterpolationAugmentations. These augmentations are wrappers around analyzers that modify the input before passing it to the analyzer.","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"We build on the basics shown in the Getting started section and start out by loading the same pre-trained LeNet5 model and MNIST input data:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"using ExplainableAI\nusing Flux\n\nusing BSON # hide\nmodel = BSON.load(\"../model.bson\", @__MODULE__)[:model] # hide\nmodel","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"using MLDatasets\nusing ImageCore, ImageIO, ImageShow\n\nindex = 10\nx, y = MNIST(Float32, :test)[10]\ninput = reshape(x, 28, 28, 1, :)\n\nconvert2image(MNIST, x)","category":"page"},{"location":"generated/augmentations/#Noise-augmentation","page":"Input augmentations","title":"Noise augmentation","text":"","category":"section"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"The NoiseAugmentation wrapper computes explanations averaged over noisy inputs. Let's demonstrate this on the Gradient analyzer. First, we compute the heatmap of an explanation without augmentation:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = Gradient(model)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"Now we wrap the analyzer in a NoiseAugmentation with 10 samples of noise. By default, the noise is sampled from a Gaussian distribution with mean 0 and standard deviation 1.","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = NoiseAugmentation(Gradient(model), 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"Note that a higher sample size is desired, as it will lead to a smoother heatmap. However, this comes at the cost of a longer computation time.","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"We can also set the standard deviation of the Gaussian distribution:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = NoiseAugmentation(Gradient(model), 50, 0.1)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"When used with a Gradient analyzer, this is equivalent to SmoothGrad:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = SmoothGrad(model, 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"We can also use any distribution from Distributions.jl, for example Poisson noise with rate lambda=05:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"using Distributions\n\nanalyzer = NoiseAugmentation(Gradient(model), 50, Poisson(0.5))\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"Is is also possible to define your own distributions or mixture distributions.","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"NoiseAugmentation can be combined with any analyzer type, for example LRP:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = NoiseAugmentation(LRP(model), 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/#Integration-augmentation","page":"Input augmentations","title":"Integration augmentation","text":"","category":"section"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"The InterpolationAugmentation wrapper computes explanations averaged over n steps of linear interpolation between the input and a reference input, which is set to zero(input) by default:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = InterpolationAugmentation(Gradient(model), 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"When used with a Gradient analyzer, this is equivalent to IntegratedGradients:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = IntegratedGradients(model, 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"To select a different reference input, pass it to the analyze or heatmap function using the keyword argument input_ref. Note that this is an arbitrary example for the sake of demonstration.","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"matrix_of_ones = ones(Float32, size(input))\n\nanalyzer = InterpolationAugmentation(Gradient(model), 50)\nheatmap(input, analyzer; input_ref=matrix_of_ones)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"Once again, InterpolationAugmentation can be combined with any analyzer type, for example LRP:","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"analyzer = InterpolationAugmentation(LRP(model), 50)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"","category":"page"},{"location":"generated/augmentations/","page":"Input augmentations","title":"Input augmentations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lrp/developer/#lrp-dev-docs","page":"Developer documentation","title":"LRP developer documentation","text":"","category":"section"},{"location":"lrp/developer/#Generic-LRP-rule-implementation","page":"Developer documentation","title":"Generic LRP rule implementation","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Before we dive into package-specific implementation details  in later sections of this developer documentation,  we first need to cover some fundamentals of LRP, starting with our notation.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"The generic LRP rule, of which the 0-, epsilon- and gamma-rules are special cases, reads[1][2]","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginequation\nR_j^k = sum_i fracrho(W_ij)  a_j^kepsilon + sum_l rho(W_il)  a_l^k + rho(b_i) R_i^k+1\nendequation","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"where ","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"W is the weight matrix of the layer\nb is the bias vector of the layer\na^k is the activation vector at the input of layer k\na^k+1 is the activation vector at the output of layer k\nR^k is the relevance vector at the input of layer k\nR^k+1 is the relevance vector at the output of layer k\nrho is a function that modifies parameters (what we call modify_parameters)\nepsilon is a small positive constant to avoid division by zero","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Subscript characters are used to index vectors and matrices  (e.g. b_i is the i-th entry of the bias vector),  while the superscripts ^k and ^k+1  indicate the relative positions of activations a and relevances R in the model. For any k, a^k and R^k have the same shape. ","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Note that every term in this equation is a scalar value, which removes the need to differentiate between matrix and element-wise operations.","category":"page"},{"location":"lrp/developer/#Linear-layers","page":"Developer documentation","title":"Linear layers","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"LRP was developed for deep rectifier networks, neural networks that are composed of linear layers with ReLU activation functions. Linear layers are layers that can be represented as affine transformations of the form ","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginequation\nf(x) = Wx + b quad \nendequation","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"This includes most commonly used types of layers, such as fully connected layers,  convolutional layers, pooling layers, and normalization layers.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"We will now describe a generic implementation of equation (1)  that can be applied to any linear layer.","category":"page"},{"location":"lrp/developer/#lrp-dev-ad-fallback","page":"Developer documentation","title":"The automatic differentiation fallback","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"The computation of the generic LRP rule can be decomposed into four steps[1]:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"beginarraylr\nz_i = sum_l rho(W_il)  a_l^k + rho(b_i)  text(Step 1) 05em\ns_i = R_i^k+1  (z_i + epsilon)            text(Step 2) 05em\nc_j = sum_i rho(W_ij)  s_i                text(Step 3) 05em\nR_j^k = a_j^k c_j                         text(Step 4)\nendarray","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"To compute step 1, we first create a modified layer,  applying rho to the weights and biases  and replacing the activation function with the identity function. The vector z is then computed using a forward pass through the modified layer. It has the same dimensionality as R^k+1 and a^k+1.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Step 2 is an element-wise division of R^k+1 by z. To avoid division by zero, a small constant epsilon is added to z when necessary.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Step 3 is trivial for fully connected layers,  as rho(W) corresponds to the weight matrix of the modified layer. For other types of linear layers, however, the implementation is more involved: A naive approach would be to construct a large matrix W that corresponds to the affine transformation Wx+b implemented by the modified layer. This has multiple drawbacks:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"the implementation is error-prone\na separate implementation is required for each type of linear layer\nfor some layer types, e.g. pooling layers, the matrix W depends on the input\nfor many layer types, e.g. convolutional layers,  the matrix W is very large and sparse, mostly consisting of zeros, leading to a large computational overhead","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"A better approach can be found by observing that the matrix W is the Jacobian of the affine transformation f(x) = Wx + b. The vector c computed in step 3 corresponds to c = s^T W, a so-called Vector-Jacobian-Product (VJP) of the vector s with the Jacobian W. ","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"VJPs are the fundamental building blocks of reverse-mode automatic differentiation (AD), and therefore implemented by most AD frameworks in a highly performant, matrix-free, GPU-accelerated manner. Note that computing the VJP is much more efficient than first computing the full Jacobian W and later multiplying it with s.  This is due to the fact that computing the full Jacobian of a function  f mathbbR^n rightarrow mathbbR^m requires computing m VJPs.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Functions that compute VJP's are commonly called pullbacks. Using the Zygote.jl AD system, we obtain the output z of a modified layer and its pullback back in a single function call:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"z, back = Zygote.pullback(modified_layer, aᵏ)","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"We then call the pullback with the vector s to obtain c:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"c = back(s)","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Finally, step 4 consists of an element-wise multiplication of the vector c  with the input activation vector a^k, resulting in the relevance vector R^k.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"This AD-based implementation is used in ExplainableAI.jl as the default method for all layer types that don't have a more optimized implementation (e.g. fully connected layers). We will refer to it as the \"AD fallback\".","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"For more background information on automatic differentiation, refer to the  JuML lecture on AD.","category":"page"},{"location":"lrp/developer/#LRP-analyzer-struct","page":"Developer documentation","title":"LRP analyzer struct","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"The LRP analyzer struct holds three fields: the model to analyze, the LRP rules to use, and pre-allocated modified_layers.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"As described in the section on Composites, applying a composite to a model will return LRP rules in nested ChainTuple and ParallelTuples. These wrapper types are used to match the structure of Flux models with Chain and Parallel layers while avoiding type piracy.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"When creating an LRP analyzer with the default keyword argument flatten=true,  flatten_model is called on the model and rules. This is done for performance reasons, as discussed in  Flattening the model.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"After passing the Model checks, modified layers are pre-allocated, once again using the ChainTuple and ParallelTuple wrapper types to match the structure of the model. If a rule doesn't modify a layer,  the corresponding entry in modified_layers is set to nothing,  avoiding unnecessary allocations.  If a rule requires multiple modified layers,  the corresponding entry in modified_layers is set to a named tuple of modified layers. Apart from these special cases,  the corresponding entry in modified_layers is simply set to the modified layer.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"For a detailed description of the layer modification mechanism, refer to the section on Advanced layer modification.","category":"page"},{"location":"lrp/developer/#Forward-and-reverse-pass","page":"Developer documentation","title":"Forward and reverse pass","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"When calling an LRP analyzer, a forward pass through the model is performed, saving the activations aᵏ for all layers k in a vector called as. This vector of activations is then used to pre-allocate the relevances R^k  for all layers in a vector called Rs. This is possible since for any layer k, a^k and R^k have the same shape. Finally, the last array of relevances R^N in Rs is set to zeros,  except for the specified output neuron, which is set to one.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"We can now run the reverse pass, iterating backwards over the layers in the model and writing relevances R^k into the pre-allocated array Rs:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"for k in length(model):-1:1\n    #                  └─ loop over layers in reverse\n    lrp!(Rs[k], rules[k], layers[k], modified_layers[i], as[k], Rs[k+1])\n    #    └─ Rᵏ: modified in-place                        └─ aᵏ  └─ Rᵏ⁺¹\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"This is done by calling low-level functions","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"function lrp!(Rᵏ, rule, layer, modified_layer, aᵏ, Rᵏ⁺¹)\n    Rᵏ .= ...\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"that implement individual LRP rules. The correct rule is applied via  multiple dispatch on the types of the arguments rule and modified_layer. The relevance Rᵏ is then computed based on the input activation aᵏ and the output relevance Rᵏ⁺¹.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"The exclamation point in the function name lrp! is a  naming convention in Julia to denote functions that modify their arguments –  in this case the first argument Rs[k], which corresponds to R^k.","category":"page"},{"location":"lrp/developer/#Rule-calls","page":"Developer documentation","title":"Rule calls","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"As discussed in The AD fallback, the default LRP fallback for unknown layers uses AD via  Zygote. Now that you are familiar with both the API and the four-step computation of the generic LRP rules, the following implementation should be straightforward to understand:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"function lrp!(Rᵏ, rule, layer, modified_layer, aᵏ, Rᵏ⁺¹)\n   # Use modified_layer if available\n   layer = isnothing(modified_layer) ? layer : modified_layer\n\n   ãᵏ = modify_input(rule, aᵏ)\n   z, back = Zygote.pullback(modified_layer, ãᵏ)\n   s = Rᵏ⁺¹ ./ modify_denominator(rule, z)\n   Rᵏ .= ãᵏ .* only(back(s))\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Not only lrp! dispatches on the rule and layer type,  but also the internal functions modify_input and modify_denominator. Unknown layers that are registered in the LRP_CONFIG use this exact function.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"All LRP rules are implemented in the file /src/lrp/rules.jl.","category":"page"},{"location":"lrp/developer/#Specialized-implementations","page":"Developer documentation","title":"Specialized implementations","text":"","category":"section"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"In other programming languages, LRP is commonly implemented in an object-oriented manner, providing a single backward pass implementation per rule. This can be seen as a form of single dispatch on the rule type.","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Using multiple dispatch, we can implement specialized versions of lrp! that not only take into account the rule type, but also the layer type,  for example for fully connected layers or reshaping layers. ","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"Reshaping layers don't affect attributions. We can therefore avoid the computational overhead of AD by writing a specialized implementation that simply reshapes back:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"function lrp!(Rᵏ, rule, layer::ReshapingLayer, modified_layer, aᵏ, Rᵏ⁺¹)\n    Rᵏ .= reshape(Rᵏ⁺¹, size(aᵏ))\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"We can even provide a specialized implementation of the generic LRP rule for Dense layers. Since we can access the weight matrix directly, we can skip the use of automatic differentiation and implement the following equation directly, using Einstein summation notation:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"R_j^k = sum_i fracrho(W_ij)  a_j^kepsilon + sum_l rho(W_il)  a_l^k + rho(b_i) R_i^k+1","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"function lrp!(Rᵏ, rule, layer::Dense, modified_layer, aᵏ, Rᵏ⁺¹)\n   # Use modified_layer if available\n   layer = isnothing(modified_layer) ? layer : modified_layer\n\n   ãᵏ = modify_input(rule, aᵏ)\n   z = modify_denominator(rule, layer(ãᵏ))\n\n   # Implement LRP using Einsum notation, where `b` is the batch index\n   @tullio Rᵏ[j, b] = layer.weight[i, j] * ãᵏ[j, b] / z[i, b] * Rᵏ⁺¹[i, b]\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"For maximum low-level control beyond modify_input and modify_denominator, you can also implement your own lrp! function and dispatch on individual rule types MyRule and layer types MyLayer:","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"function lrp!(Rᵏ, rule::MyRule, layer::MyLayer, modified_layer, aᵏ, Rᵏ⁺¹)\n    Rᵏ .= ...\nend","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"[1]: G. Montavon et al., Layer-Wise Relevance Propagation: An Overview","category":"page"},{"location":"lrp/developer/","page":"Developer documentation","title":"Developer documentation","text":"[2]: W. Samek et al., Explaining Deep Neural Networks and Beyond: A Review of Methods and Applications","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"EditURL = \"../literate/example.jl\"","category":"page"},{"location":"generated/example/#docs-getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"For this first example, we already have loaded a pre-trained LeNet5 model to look at explanations on the MNIST dataset.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"using ExplainableAI\nusing Flux\n\nusing BSON # hide\nmodel = BSON.load(\"../model.bson\", @__MODULE__)[:model] # hide\nmodel","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"note: Supported models\nExplainableAI.jl can be used on any differentiable classifier.Only LRP requires models from Flux.jl.","category":"page"},{"location":"generated/example/#Preparing-the-model","page":"Getting started","title":"Preparing the model","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"For models with softmax activations on the output, it is necessary to call strip_softmax before analyzing.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"model = strip_softmax(model);\nnothing #hide","category":"page"},{"location":"generated/example/#Preparing-the-input-data","page":"Getting started","title":"Preparing the input data","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"We use MLDatasets to load a single image from the MNIST dataset:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"using MLDatasets\nusing ImageCore, ImageIO, ImageShow\n\nindex = 10\nx, y = MNIST(Float32, :test)[10]\n\nconvert2image(MNIST, x)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"By convention in Flux.jl, this input needs to be resized to WHCN format by adding a color channel and batch dimensions.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"input = reshape(x, 28, 28, 1, :);\nnothing #hide","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"note: Input format\nFor any explanation of a model, ExplainableAI.jl assumes the batch dimension to come last in the input.For the purpose of heatmapping, the input is assumed to be in WHCN order (width, height, channels, batch), which is Flux.jl's convention.","category":"page"},{"location":"generated/example/#Explanations","page":"Getting started","title":"Explanations","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"We can now select an analyzer of our choice and call analyze to get an Explanation:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"analyzer = LRP(model)\nexpl = analyze(input, analyzer);\nnothing #hide","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"The return value expl is of type Explanation and bundles the following data:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"expl.val: the numerical output of the analyzer, e.g. an attribution or gradient\nexpl.output: the model output for the given analyzer input\nexpl.neuron_selection: the neuron index used for the explanation\nexpl.analyzer: a symbol corresponding the used analyzer, e.g. :LRP\nexpl.extras: an optional named tuple that can be used by analyzers to return additional information.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"We used an LRP analyzer, so expl.analyzer is :LRP.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"expl.analyzer","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"By default, the explanation is computed for the maximally activated output neuron. Since our digit is a 9 and Julia's indexing is 1-based, the output neuron at index 10 of our trained model is maximally activated.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"expl.neuron_selection","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"Finally, we obtain the result of the analyzer in form of an array.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"expl.val","category":"page"},{"location":"generated/example/#Heatmapping-basics","page":"Getting started","title":"Heatmapping basics","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"Since the array expl.val is not very informative at first sight, we can visualize Explanations by computing a heatmap:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"heatmap(expl)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"If we are only interested in the heatmap, we can combine analysis and heatmapping into a single function call:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"heatmap(input, analyzer)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"For a more detailed explanation of the heatmap function, refer to the heatmapping section.","category":"page"},{"location":"generated/example/#docs-analyzers-list","page":"Getting started","title":"List of analyzers","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"Currently, the following analyzers are implemented:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"Gradient\nInputTimesGradient\nSmoothGrad\nIntegratedGradients\nLRP\nRules\nZeroRule\nEpsilonRule\nGammaRule\nGeneralizedGammaRule\nWSquareRule\nFlatRule\nZBoxRule\nZPlusRule\nAlphaBetaRule\nPassRule\nComposite\nEpsilonGammaBox\nEpsilonPlus\nEpsilonPlusFlat\nEpsilonAlpha2Beta1\nEpsilonAlpha2Beta1Flat","category":"page"},{"location":"generated/example/#Neuron-selection","page":"Getting started","title":"Neuron selection","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"By passing an additional index to our call to analyze, we can compute an explanation with respect to a specific output neuron. Let's see why the output wasn't interpreted as a 4 (output neuron at index 5)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"expl = analyze(input, analyzer, 5)\nheatmap(expl)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"This heatmap shows us that the \"upper loop\" of the hand-drawn 9 has negative relevance with respect to the output neuron corresponding to digit 4!","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"note: Note\nThe output neuron can also be specified when calling heatmap:heatmap(input, analyzer, 5)","category":"page"},{"location":"generated/example/#Analyzing-batches","page":"Getting started","title":"Analyzing batches","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"ExplainableAI also supports explanations of input batches:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"batchsize = 20\nxs, _ = MNIST(Float32, :test)[1:batchsize]\nbatch = reshape(xs, 28, 28, 1, :) # reshape to WHCN format\nexpl = analyze(batch, analyzer);\nnothing #hide","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"This will return a single Explanation expl for the entire batch. Calling heatmap on expl will detect the batch dimension and return a vector of heatmaps.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"heatmap(expl)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"For more information on heatmapping batches, refer to the heatmapping documentation.","category":"page"},{"location":"generated/example/#gpu-docs","page":"Getting started","title":"GPU support","text":"","category":"section"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"All analyzers support GPU backends, building on top of Flux.jl's GPU support. Using a GPU only requires moving the input array and model weights to the GPU.","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"For example, using CUDA.jl:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"using CUDA, cuDNN\nusing Flux\nusing ExplainableAI\n\n# move input array and model weights to GPU\ninput = input |> gpu # or gpu(input)\nmodel = model |> gpu # or gpu(model)\n\n# analyzers don't require calling `gpu`\nanalyzer = LRP(model)\n\n# explanations are computed on the GPU\nexpl = analyze(input, analyzer)","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"Some operations, like saving, require moving explanations back to the CPU. This can be done using Flux's cpu function:","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"val = expl.val |> cpu # or cpu(expl.val)\n\nusing BSON\nBSON.@save \"explanation.bson\" val","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"generated/example/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"EditURL = \"../../literate/lrp/custom_layer.jl\"","category":"page"},{"location":"generated/lrp/custom_layer/#docs-custom-layers","page":"Supporting new layer types","title":"Supporting new layers and activation functions","text":"","category":"section"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"One of the design goals of ExplainableAI.jl is to combine ease of use and extensibility for the purpose of research. This example will show you how to extent LRP to new layer types and activation functions.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"using Flux\nusing ExplainableAI","category":"page"},{"location":"generated/lrp/custom_layer/#docs-lrp-model-checks","page":"Supporting new layer types","title":"Model checks","text":"","category":"section"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"To assure that novice users use LRP according to best practices, ExplainableAI.jl runs strict model checks when creating an LRP analyzer.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Let's demonstrate this by defining a new layer type that doubles its input","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"struct MyDoublingLayer end\n(::MyDoublingLayer)(x) = 2 * x\n\nmylayer = MyDoublingLayer()\nmylayer([1, 2, 3])","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"and by defining a model that uses this layer:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"model = Chain(\n    Dense(100, 20),\n    MyDoublingLayer()\n);\nnothing #hide","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Creating an LRP analyzer, e.g. LRP(model), will throw an ArgumentError and print a summary of the model check in the REPL:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"julia> LRP(model)\n  ChainTuple(\n    Dense(100 => 20)  => supported,\n    MyDoublingLayer() => unknown layer type,\n  ),\n\n  LRP model check failed\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Found unknown layer types or activation functions that are not supported by ExplainableAI's LRP implementation yet.\n\n  LRP assumes that the model is a deep rectifier network that only contains ReLU-like activation functions.\n\n  If you think the missing layer should be supported by default, please submit an issue (https://github.com/adrhill/ExplainableAI.jl/issues).\n\n  [...]\n\nERROR: Unknown layer or activation function found in model","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"LRP should only be used on deep rectifier networks and ExplainableAI doesn't recognize MyDoublingLayer as a compatible layer by default. It will therefore return an error and a model check summary instead of returning an incorrect explanation.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"However, if we know MyDoublingLayer is compatible with deep rectifier networks, we can register it to tell ExplainableAI that it is ok to use. This will be shown in the following section.","category":"page"},{"location":"generated/lrp/custom_layer/#Registering-layers","page":"Supporting new layer types","title":"Registering layers","text":"","category":"section"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"The error in the model check will stop after registering our custom layer type MyDoublingLayer as \"supported\" by ExplainableAI.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"This is done using the function LRP_CONFIG.supports_layer, which should be set to return true for the type MyDoublingLayer:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"LRP_CONFIG.supports_layer(::MyDoublingLayer) = true","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Now we can create and run an analyzer without getting an error:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"analyzer = LRP(model)","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"note: Registering functions\nFlux's Chains can also contain functions, e.g. flatten. This kind of layer can be registered asLRP_CONFIG.supports_layer(::typeof(flatten)) = true","category":"page"},{"location":"generated/lrp/custom_layer/#Registering-activation-functions","page":"Supporting new layer types","title":"Registering activation functions","text":"","category":"section"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"The mechanism for registering custom activation functions is analogous to that of custom layers:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"myrelu(x) = max.(0, x)\n\nmodel = Chain(\n    Dense(784, 100, myrelu),\n    Dense(100, 10),\n);\nnothing #hide","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Once again, creating an LRP analyzer for this model will throw an ArgumentError and display the following model check summary:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"julia> LRP(model)\n  ChainTuple(\n    Dense(784 => 100, myrelu) => unsupported or unknown activation function myrelu,\n    Dense(100 => 10)          => supported,\n  ),\n\n  LRP model check failed\n  ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\n  Found unknown layer types or activation functions that are not supported by ExplainableAI's LRP implementation yet.\n\n  LRP assumes that the model is a deep rectifier network that only contains ReLU-like activation functions.\n\n  If you think the missing layer should be supported by default, please submit an issue (https://github.com/adrhill/ExplainableAI.jl/issues).\n\n  [...]\n\nERROR: Unknown layer or activation function found in model","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Registation works by defining the function LRP_CONFIG.supports_activation as true:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"LRP_CONFIG.supports_activation(::typeof(myrelu)) = true","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"now the analyzer can be created without error:","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"analyzer = LRP(model)","category":"page"},{"location":"generated/lrp/custom_layer/#Skipping-model-checks","page":"Supporting new layer types","title":"Skipping model checks","text":"","category":"section"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"All model checks can be skipped at your own risk by setting the LRP-analyzer keyword argument skip_checks=true.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"struct UnknownLayer end\n(::UnknownLayer)(x) = x\n\nunknown_activation(x) = max.(0, x)\n\nmodel = Chain(Dense(100, 20, unknown_activation), MyDoublingLayer())\n\nLRP(model; skip_checks=true)","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"Instead of throwing the usual ERROR: Unknown layer or activation function found in model, the LRP analyzer was created without having to register either the layer UnknownLayer or the activation function unknown_activation.","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"","category":"page"},{"location":"generated/lrp/custom_layer/","page":"Supporting new layer types","title":"Supporting new layer types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"EditURL = \"../../literate/lrp/basics.jl\"","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-basics","page":"Basic usage","title":"Basic usage of LRP","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This example will show you best practices for using LRP, building on the basics shown in the Getting started section.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"note: TLDR\nUse strip_softmax to strip the output softmax from your model. Otherwise model checks will fail.\nUse canonize to fuse linear layers.\nDon't just call LRP(model), instead use a Composite to apply LRP rules to your model. Read Assigning rules to layers.\nBy default, LRP will call flatten_model to flatten your model. This reduces computational overhead.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"We start out by loading a small convolutional neural network:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"using ExplainableAI\nusing Flux\n\nmodel = Chain(\n    Chain(\n        Conv((3, 3), 3 => 8, relu; pad=1),\n        Conv((3, 3), 8 => 8, relu; pad=1),\n        MaxPool((2, 2)),\n        Conv((3, 3), 8 => 16; pad=1),\n        BatchNorm(16, relu),\n        Conv((3, 3), 16 => 8, relu; pad=1),\n        BatchNorm(8, relu),\n    ),\n    Chain(\n        Flux.flatten,\n        Dense(2048 => 512, relu),\n        Dropout(0.5),\n        Dense(512 => 100, softmax)\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This model contains two chains: the convolutional layers and the fully connected layers.","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-model-prep","page":"Basic usage","title":"Model preparation","text":"","category":"section"},{"location":"generated/lrp/basics/#docs-lrp-strip-softmax","page":"Basic usage","title":"Stripping the output softmax","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"When using LRP, it is recommended to explain output logits instead of probabilities. This can be done by stripping the output softmax activation from the model using the strip_softmax function:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"model = strip_softmax(model)","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"If you don't remove the output softmax, model checks will fail.","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-canonization","page":"Basic usage","title":"Canonizing the model","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"LRP is not invariant to a model's implementation. Applying the GammaRule to two linear layers in a row will yield different results than first fusing the two layers into one linear layer and then applying the rule. This fusing is called \"canonization\" and can be done using the canonize function:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"model_canonized = canonize(model)","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"After canonization, the first BatchNorm layer has been fused into the preceding Conv layer. The second BatchNorm layer wasn't fused since its preceding Conv layer has a ReLU activation function.","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-flatten-model","page":"Basic usage","title":"Flattening the model","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"ExplainableAI.jl's LRP implementation supports nested Flux Chains and Parallel layers. However, it is recommended to flatten the model before analyzing it.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"LRP is implemented by first running a forward pass through the model, keeping track of the intermediate activations, followed by a backward pass that computes the relevances.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"To keep the LRP implementation simple and maintainable, ExplainableAI.jl does not pre-compute \"nested\" activations. Instead, for every internal chain, a new forward pass is run to compute activations.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"By \"flattening\" a model, this overhead can be avoided. For this purpose, ExplainableAI.jl provides the function flatten_model:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"model_flat = flatten_model(model)","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This function is called by default when creating an LRP analyzer. Note that we pass the unflattened model to the analyzer, but analyzer.model is flattened:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"analyzer = LRP(model)\nanalyzer.model","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"If this flattening is not desired, it can be disabled by passing the keyword argument flatten=false to the LRP constructor.","category":"page"},{"location":"generated/lrp/basics/#LRP-rules","page":"Basic usage","title":"LRP rules","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"By default, the LRP constructor will assign the ZeroRule to all layers.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"LRP(model)","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This analyzer will return heatmaps that look identical to InputTimesGradient.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"LRP's strength lies in assigning different rules to different layers, based on their functionality in the neural network[1]. ExplainableAI.jl implements many LRP rules out of the box, but it is also possible to implement custom rules.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"To assign different rules to different layers, use one of the composites presets, or create your own composite, as described in Assigning rules to layers.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"composite = EpsilonPlusFlat() # using composite preset EpsilonPlusFlat","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"LRP(model, composite)","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-layerwise","page":"Basic usage","title":"Computing layerwise relevances","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"If you are interested in computing layerwise relevances, call analyze with an LRP analyzer and the keyword argument layerwise_relevances=true.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"The layerwise relevances can be accessed in the extras field of the returned Explanation:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"input = rand(Float32, 32, 32, 3, 1) # dummy input for our convolutional neural network\n\nexpl = analyze(input, analyzer; layerwise_relevances=true)\nexpl.extras.layerwise_relevances","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"Note that the layerwise relevances are only kept for layers in the outermost Chain of the model. When using our unflattened model, we only obtain three layerwise relevances, one for each chain in the model and the output relevance:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"analyzer = LRP(model; flatten=false) # use unflattened model\n\nexpl = analyze(input, analyzer; layerwise_relevances=true)\nexpl.extras.layerwise_relevances","category":"page"},{"location":"generated/lrp/basics/#docs-lrp-performance","page":"Basic usage","title":"Performance tips","text":"","category":"section"},{"location":"generated/lrp/basics/#Using-LRP-with-a-GPU","page":"Basic usage","title":"Using LRP with a GPU","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"Like all other analyzers, LRP can be used on GPUs. Follow the instructions on GPU support.","category":"page"},{"location":"generated/lrp/basics/#Using-LRP-without-a-GPU","page":"Basic usage","title":"Using LRP without a GPU","text":"","category":"section"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"Using Julia's package extension mechanism, ExplainableAI.jl's LRP implementation can optionally make use of Tullio.jl and LoopVectorization.jl for faster LRP rules on dense layers.","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This only requires loading the packages before loading ExplainableAI.jl:","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"using LoopVectorization, Tullio\nusing ExplainableAI","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"[1]: G. Montavon et al., Layer-Wise Relevance Propagation: An Overview","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"generated/lrp/basics/","page":"Basic usage","title":"Basic usage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"EditURL = \"../../literate/lrp/custom_rules.jl\"","category":"page"},{"location":"generated/lrp/custom_rules/#docs-custom-rules","page":"Custom LRP rules","title":"Custom LRP rules","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"One of the design goals of ExplainableAI.jl is to combine ease of use and extensibility for the purpose of research.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"This example will show you how to implement custom LRP rules. building on the basics shown in the Getting started section.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"We start out by loading the same pre-trained LeNet5 model and MNIST input data:","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"using ExplainableAI\nusing Flux\nusing MLDatasets\nusing ImageCore\nusing BSON\n\nindex = 10\nx, y = MNIST(Float32, :test)[10]\ninput = reshape(x, 28, 28, 1, :)\n\nmodel = BSON.load(\"../../model.bson\", @__MODULE__)[:model] # hide\nmodel","category":"page"},{"location":"generated/lrp/custom_rules/#Implementing-a-custom-rule","page":"Custom LRP rules","title":"Implementing a custom rule","text":"","category":"section"},{"location":"generated/lrp/custom_rules/#Step-1:-Define-rule-struct","page":"Custom LRP rules","title":"Step 1: Define rule struct","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"Let's define a rule that modifies the weights and biases of our layer on the forward pass. The rule has to be of supertype AbstractLRPRule.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"struct MyGammaRule <: AbstractLRPRule end","category":"page"},{"location":"generated/lrp/custom_rules/#docs-custom-rules-impl","page":"Custom LRP rules","title":"Step 2: Implement rule behavior","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"It is then possible to dispatch on the following four utility functions with the rule type MyCustomLRPRule to define custom rules without writing boilerplate code.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"modify_input(rule::MyGammaRule, input)\nmodify_parameters(rule::MyGammaRule, parameter)\nmodify_denominator(rule::MyGammaRule, denominator)\nis_compatible(rule::MyGammaRule, layer)","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"By default:","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"modify_input doesn't change the input\nmodify_parameters doesn't change the parameters\nmodify_denominator avoids division by zero by adding a small epsilon-term (1.0f-9)\nis_compatible returns true if a layer has fields weight and bias","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"To extend internal functions, import them explicitly:","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"import ExplainableAI: modify_parameters\n\nmodify_parameters(::MyGammaRule, param) = param + 0.25f0 * relu.(param)","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"Note that we didn't implement three of the four functions. This is because the defaults are sufficient to implement the GammaRule.","category":"page"},{"location":"generated/lrp/custom_rules/#Step-3:-Use-rule-in-LRP-analyzer","page":"Custom LRP rules","title":"Step 3: Use rule in LRP analyzer","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"We can directly use our rule to make an analyzer!","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"rules = [\n    ZPlusRule(),\n    EpsilonRule(),\n    MyGammaRule(), # our custom GammaRule\n    EpsilonRule(),\n    ZeroRule(),\n    ZeroRule(),\n    ZeroRule(),\n    ZeroRule(),\n]\nanalyzer = LRP(model, rules)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"We just implemented our own version of the γ-rule in 2 lines of code. The heatmap perfectly matches the pre-implemented GammaRule:","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"rules = [\n    ZPlusRule(),\n    EpsilonRule(),\n    GammaRule(), # XAI.jl's GammaRule\n    EpsilonRule(),\n    ZeroRule(),\n    ZeroRule(),\n    ZeroRule(),\n    ZeroRule(),\n]\nanalyzer = LRP(model, rules)\nheatmap(input, analyzer)","category":"page"},{"location":"generated/lrp/custom_rules/#Performance-tips","page":"Custom LRP rules","title":"Performance tips","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"Make sure functions like modify_parameters don't promote the type of weights (e.g. from Float32 to Float64).\nIf your rule MyRule doesn't modify weights or biases, defining modify_layer(::MyRule, layer) = nothing can provide reduce memory allocations and improve performance.","category":"page"},{"location":"generated/lrp/custom_rules/#docs-custom-rules-advanced","page":"Custom LRP rules","title":"Advanced layer modification","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"For more granular control over weights and biases, modify_weight and modify_bias can be used.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"If the layer doesn't use weights (layer.weight) and biases (layer.bias), ExplainableAI provides a lower-level variant of modify_parameters called modify_layer. This function is expected to take a layer and return a new, modified layer. To add compatibility checks between rule and layer types, extend is_compatible.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"warning: Extending modify_layer\nUse of a custom function modify_layer will overwrite functionality of modify_parameters, modify_weight and modify_bias for the implemented combination of rule and layer types. This is due to the fact that internally, modify_weight and modify_bias are called by the default implementation of modify_layer. modify_weight and modify_bias in turn call modify_parameters by default.The default call structure looks as follows:┌─────────────────────────────────────────┐\n│              modify_layer               │\n└─────────┬─────────────────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│   modify_weight   │ │    modify_bias    │\n└─────────┬─────────┘ └─────────┬─────────┘\n          │ calls               │ calls\n┌─────────▼─────────┐ ┌─────────▼─────────┐\n│ modify_parameters │ │ modify_parameters │\n└───────────────────┘ └───────────────────┘Therefore modify_layer should only be extended for a specific rule and a specific layer type.","category":"page"},{"location":"generated/lrp/custom_rules/#Advanced-LRP-rules","page":"Custom LRP rules","title":"Advanced LRP rules","text":"","category":"section"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"To implement custom LRP rules that require more than modify_layer, modify_input and modify_denominator, take a look at the LRP developer documentation.","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"","category":"page"},{"location":"generated/lrp/custom_rules/","page":"Custom LRP rules","title":"Custom LRP rules","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ExplainableAI","category":"page"},{"location":"#ExplainableAI.jl","page":"Home","title":"ExplainableAI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Explainable AI in Julia using Flux.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package and its dependencies, open the Julia REPL and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add ExplainableAI","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#General-usage","page":"Home","title":"General usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"generated/example.md\",\n    \"generated/heatmapping.md\",\n    \"generated/augmentations.md\",\n]\nDepth = 3","category":"page"},{"location":"#LRP","page":"Home","title":"LRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"generated/lrp/basics.md\",\n    \"generated/lrp/composites.md\",\n    \"generated/lrp/custom_layer.md\",\n    \"generated/lrp/custom_rules.md\",\n    \"lrp/developer.md\",\n]\nDepth = 3","category":"page"},{"location":"#API-reference","page":"Home","title":"API reference","text":"","category":"section"},{"location":"#General","page":"Home","title":"General","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\"]\nDepth = 2","category":"page"},{"location":"#LRP-2","page":"Home","title":"LRP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lrp/api.md\"]\nDepth = 2","category":"page"}]
}
